<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>智能进化算法 | 木子士心豪の博客</title><meta name="keywords" content="进化算法笔记"><meta name="author" content="木子士心豪"><meta name="copyright" content="木子士心豪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章介绍了GA算法与HS算法的原理介绍，以及关于GA算法的具体实现方法；第二章使用遗传算法实现JSP优化；第三章使用遗传算法完成FJSP调度优化；第四章使用遗传算法完成HSP调度优化">
<meta property="og:type" content="article">
<meta property="og:title" content="智能进化算法">
<meta property="og:url" content="https://yuluotianhan.github.io/2022/01/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="木子士心豪の博客">
<meta property="og:description" content="第一章介绍了GA算法与HS算法的原理介绍，以及关于GA算法的具体实现方法；第二章使用遗传算法实现JSP优化；第三章使用遗传算法完成FJSP调度优化；第四章使用遗传算法完成HSP调度优化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.picsum.photos/id/641/2509/1673.jpg?hmac=ECuwhiaywfcq8Uz33JwR66SNqYHg5gs-XEh4NzV7uq8">
<meta property="article:published_time" content="2022-01-30T13:30:00.000Z">
<meta property="article:modified_time" content="2022-01-31T07:48:32.882Z">
<meta property="article:author" content="木子士心豪">
<meta property="article:tag" content="进化算法笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.picsum.photos/id/641/2509/1673.jpg?hmac=ECuwhiaywfcq8Uz33JwR66SNqYHg5gs-XEh4NzV7uq8"><link rel="shortcut icon" href="/./img/tailuo.png"><link rel="canonical" href="https://yuluotianhan.github.io/2022/01/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '智能进化算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-31 15:48:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="木子士心豪の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/tailuo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.picsum.photos/id/641/2509/1673.jpg?hmac=ECuwhiaywfcq8Uz33JwR66SNqYHg5gs-XEh4NzV7uq8')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">木子士心豪の博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">智能进化算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-30T13:30:00.000Z" title="发表于 2022-01-30 21:30:00">2022-01-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-31T07:48:32.882Z" title="更新于 2022-01-31 15:48:32">2022-01-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="智能进化算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><ul>
<li><p>有意义积木块编码原则：应使用能易于产生与所求问题相关的且具有低阶、短定义长度模式的编码方案</p>
<ul>
<li>模式是指具有某些基因相似性的个体的集合</li>
<li>具有低阶、短定义长度且适应度较高的模式称之为构造优良个体的积木块或基因块</li>
</ul>
</li>
<li><p>最小字符集编码原则：应使用能使问题得到自然表示或描述的具有最小编码字符集的编码方案</p>
<p>编码方法大致分为三类：二进制编码，浮点数编码，符号编码方法</p>
</li>
</ul>
<h4 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h4><p>二进制编码符号串的长度与问题所要求的求解精度有关。详见遗传算法原理及应用P34</p>
<p>二进制编码方法有以下优点：</p>
<p>​    编码、解码操作简单易行</p>
<p>​    交叉、变异等遗传操作便于实现</p>
<p>​    符合最小字符集编码原则</p>
<p>​    便于利用模式定理对算法进行理论分析</p>
<h4 id="格雷码编码"><a href="#格雷码编码" class="headerlink" title="格雷码编码"></a>格雷码编码</h4><p>由于遗传运算的随机特性而使得其局部搜索能力较差。为改进这个特性，人们提出用格雷码(Gray code )来对个体进行编码。</p>
<p>格雷码是这样的一种编码方法，其连续的两个整数所对应的编码值之间仅仅只有-一个码位是不相同的，其余码位都完全相同。例如十进制数0~15之间的二进制码和相应的格雷码如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311531116" alt="img"></p>
<ul>
<li><p>二进制码转换成二进制格雷码：</p>
<p>二进制码转换成二进制格雷码，其法则是保留二进制码的最高位作为格雷码的最高位，而次高位格雷码为二进制码的高位与次高位相异或，而格雷码其余各位与次高位的求法相类似。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311531757" alt="img"></p>
<ul>
<li><p>格雷码转二进制码：</p>
<p>二进制格雷码转换成二进制码,其法则是保留格雷码的最高位作为自然二进制码的最高位，而次高位自然二进制码为高位自然二进制码与次高位格雷码相异或，而自然二进制码的其余各位与次高位自然二进制码的求法相类似。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311531457" alt="转换示意图" style="zoom:80%;"></li>
<li><p>格雷码特点：<strong>任意两个整数的差是这两个整数所对应的格雷码之间的海明距离</strong></p>
</li>
<li><p>格雷码优点：</p>
<ul>
<li>便于提高遗传算法的<strong>局部搜索</strong>能力</li>
<li>交叉、变异等遗传操作便于实现</li>
<li>符合最小字符集编码原则</li>
<li>便于利用模式定理对算法进行理论分析</li>
</ul>
</li>
</ul>
<h4 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h4><p>​        对于一些多维、高精度要求的连续函数优化问题，使用二进制编码来表示个体时将会有一些不利之处。</p>
<p>​        首先是二进制编码存在着连续函数离散化时的映射误差。个体编码串的长度较短时，可能达不到精度要求;而<strong>个体编码串的长度较长时，虽然能提高编码精度，但却会使遗传算法的搜索空间急剧扩大</strong>。例如、若使用二进制编码方法来处理一个含有100个决策变量的优化问题，其中每个决策变量的取值范围是[一250，250]，要求精度取小数点后5位小数，为达到这个精度要求，每个变量必须用26位长的二进制编码符号串来表示，这是因为:<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311531525.png" alt="image-20210415190758397"></p>
<p>​        这样每个个体必须用100×26位长的二进制编码符号串表示。亦即此时遗传算法的搜索空间大约是2^2600。在如此之大的搜索空间寻优肯定会使得遗传算法的运行性能相当差，甚至可能无法进行下去。</p>
<p>​        为改进二进制编码方法的这些缺点，人们提出了个体的浮点数编码方法。所谓<strong>浮点数编码方法</strong>，是指个体的每个基因值用某一范围内的一个浮点数来表示，个体的编码长度等于其决策变量的个数。因为这种编码方法使用的是决策变量的真实值，所以浮点数编码方法也叫做真值编码方法。</p>
<p>​        在浮点数编码方法中，必须保证基因值在给定的区间限制范围内，遗传算法中所使用的交叉、变异等遗传算子也必须保证其运算结果所产生的新个体的基因值也在这个区间限制范围内。再者，当用多个字节来表示一个基因值时，交叉运算必须在两个基因的分界字节处进行，而不能在某个基因的中间字节分隔处进行。</p>
<ul>
<li>浮点数编码方法有下面几个优点:<ul>
<li>(1)  适合于在遗传算法中表示范围较大的数。</li>
<li>(2）适合于精度要求较高的遗传算法。</li>
<li>(3）便于较大空间的遗传搜索。</li>
<li>(4〉改善了遗传算法的计算复杂性，提高了运算效率。</li>
<li>(5）便于遗传算法与经典优化方法的混合使用。</li>
<li>(6〉便于设计针对问题的专门知识的知识型遗传算子。</li>
<li>(7）便于处理复杂的决策变量约束条件。</li>
</ul>
</li>
</ul>
<h4 id="符合编码方法"><a href="#符合编码方法" class="headerlink" title="符合编码方法"></a>符合编码方法</h4><p>​        符号编码方法是指个体染色体编码串中的基因值取自一个无数值含义、而只有代码含义的符号集。这个符号集可以是一个字母表,如{A，B，C，D，…};也可以是一个数字序号表，如∶{1，2，3，4、5,…};还可以是一个代码表，如{A1，A2，A3，A4，A5，…}等等。</p>
<p>例如，对于旅行商问题，假设有n个城巿分别记为C<del>1</del>、C<del>2</del>、.…、C<del>n</del>，将各个城市的代号按其被访问的顺序连接在一起，就可构成一个表示旅行路线的个体。如</p>
<p>​                                                                                             x: [ C<del>1</del>，C<del>2</del>，…，C<del>n</del> ]。</p>
<p>就表示顺序访问城市C<del>1</del>、C<del>2</del>、…、C<del>n</del>。</p>
<p>若将各个城市按其代号的下标进行编号，则这个个体也可表示为:</p>
<p>​                                                                                                X: [ 1，2，…，n ]</p>
<ul>
<li><p>符号编码的主要优点是:</p>
<ul>
<li>(1)符合有意义积木块编码原则。</li>
<li>(2)便于在遗传算法中利用所求解问题的专门知识。</li>
<li>(3〉便于遗传算法与相关近似算法之间的混合使用。</li>
</ul>
<p>但对于使用符号编码方法的遗传算法，一般需要认真设计交叉、变异等遗传运算的操作方法，以满足问题的各种约束要求，这样才</p>
</li>
</ul>
<p>能提高算法的搜索性能。</p>
<p>​    </p>
<h4 id="多参数级联编码方法"><a href="#多参数级联编码方法" class="headerlink" title="多参数级联编码方法"></a>多参数级联编码方法</h4><p>​        一般常见的优化问题往往含有多个决策变量，对含有多个变量的个体进行编码的方法称之为多参数编码方法。</p>
<p>​        最常用和最基本的方法:将各个参数分别以某种编码方法进行编码，然后再将它们的编码按一定顺序联接在一起就组成了表示全部参数的个体编码。这种编码方法称为多参数级联编码方法。</p>
<p>​        在进行多参数级联编码时，每个参数的编码方式可以是二进制编码、格雷码、浮点数编码或符号编码等编码方式中的一种，每个参数可以具有不同的上下界，也可以有不同的编码长度或编码精度。例如，假设一种个体含有n个参数，每个参数用l<del>i</del>( i= 1，2，…，n）位的二进制编码来表示，则该个体可表示为:<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311531423.png" alt="image-20210415193737459"></p>
<p>​        该编码串的总长度为l=Σl<del>i</del>;。这也是多参数二进制级联编码的一种通用形式。</p>
<h4 id="多参数交叉编码方法"><a href="#多参数交叉编码方法" class="headerlink" title="多参数交叉编码方法"></a>多参数交叉编码方法</h4><p>​        多参数交叉编码方法的基本思想是:<strong>将各个参数中起主要作用的码位集中在一起，这样它们就不易于被遗传算子破坏掉</strong>。<br>​        在进行多参数交叉编码时，可先对各个参数进行分组编码(假设共有n个参数,每个参数都用长度为m 的二进制编码串来表示)﹔然后取各个参数编码串中的最高位联接在一起，以它们作为个体编码串的前n位编码，再取各个参数编码串中的次高位联接在一起，以它们作为个体编码串的第二组n位.编码，……，取各个参数编码串中的最后一位联接在一起，以它们作为个体编码串的最后n位。这样所组成的长度为m×n 位的编码串就是多参数的一个交叉编码串，如下所示:</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532924.png" alt="image-20210415194057702" style="zoom:80%;">

<p>​        在前述多参数的级联编码方法中，各个参数的编码值集中在一起，这样各个参数的局部编码结构就不易被遗传算子破坏掉，它适合于各参数之间的相互关系较弱，特别是某一个或少数几个参数起主要作用时的优化问题。而多参数的交叉编码方法特别适合于各个参数之间的相互关系较强、各参数对最优解的贡献相当时的优化问题，因为在这种交叉编码方法中，用来表示各个参数值的二进制编码的最高位被集中在了一起，它们就不易被遗传算子破坏掉，而这些最高位在表示各个参数值时所起的作用最强，这样就可以尽量地维持各参数之间的相互关系。</p>
<h3 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h3><p>​        遗传算法中使用适应度这个概念来度量群体中各个个体在优化计算中有可能达到或接近于或有助于找到最优解的优良程度。适应度较高的个体遗传到下一代的概率就较大;而适应度较低的个体遗传到下一代的概率就相对小一些。<strong>度量个体适应度的函数称为适应度函数</strong>(Fitness Function)。</p>
<ul>
<li>评价个体适应度的一般过程：<ul>
<li>(1）对个体编码串进行解码处理后，可得到个体的表现型。</li>
<li>(2)由个体的表现型可计算出对应个体的目标函数值。</li>
<li>(3）根据最优化问题的类型，由目标函数值按一定的转换规则求出个体的适应度。</li>
</ul>
</li>
</ul>
<p>​        最优化问题可分为两大类，一类为求目标函数的全局最大值，另一类为求目标函数的全局最小值。由解空间中某一点的目标函数值</p>
<p>f (X）到搜索空间中对应个体的适应度函数值F(X)的转换方法:</p>
<ul>
<li>对于求最大值的问题，做下述转换：</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532540.png" alt="image-20210415195724902" style="zoom:67%;">

<ul>
<li>对于求最小值的问题，做下述转换：</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532470.png" alt="image-20210415195650671" style="zoom:67%;">



<h4 id="适应的尺度变换"><a href="#适应的尺度变换" class="headerlink" title="适应的尺度变换"></a>适应的尺度变换</h4><p>​        <strong>如何确定适应度对遗传算法的性能有较大影响。</strong>例如，在遗传算法运行的初期阶段，群体中可能会有少数几个个体的适应度相对其他个体来说非常高。若按照常用的比例选择算子来确定个体的遗传数量时，则这几个相对较好的个体将在下一代群体中占有很高的比例，在极端情况下或当群体规模较小时，新的群体甚至完全由这样的少数几个个体所组成。这时产生新个体作用较大的交叉算子就起不了什么作用，因为<strong>相同的两个个体不论在何处进行交叉操作都永远不会产生出新的个体</strong>，如下所示:</p>
<p>​                                                                <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532594.png" alt="image-20210415200306668" style="zoom:67%;"></p>
<p>​        这样就会使群体的多样性降低，容易导致遗传算法发生<strong>早熟现象(或称早期收敛</strong>)，使遗传算法所求到的解停留在某一局部最优点上.。为了克服这种现象，我们希望在遗传算法运行的初期阶段，算法能够对一些适应度较高的个体进行控制，降低其适应度与其他个体适应度之间的差异程度，从而限制其复制数量，以维护群体的多样性。</p>
<p>​        又例如，在遗传算法运行的后期阶段，<strong>群体中所有个体的平均适应度可能会接近于群体中最佳个体的适应度</strong>。也就是说，大部分个体的适应度和最佳个体的适应度差异不大，它们之间无竞争力，都会有以相接近的概率被遗传到下一代的可能性，从而使得<strong>进化过程无竞争性可言，只是一种随机的选择过程</strong>。这将导致无法对某些重点区域进行重点搜素，从而影响遗传算法的运行效率。为了克服这种现象，我们希望在遗传算法运行的后期阶段，算法能够<strong>对个体的适应度进行适当的放大</strong>，<strong>扩大最佳个体适应度与其他个体适应度之间的差异程度</strong>，以提高个体之间的竞争性。</p>
<p>​        目前常用的个体适应度尺度变化方法主要有三种：<strong>线性尺度变化、乘幂尺度变化和指数尺度变换</strong></p>
<ul>
<li><p>线性尺度变换：</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532634.png" alt="image-20210415201800170" style="zoom:50%;">

<p>一般需要满足两个条件：</p>
<p>​    1、尺度变换后全部个体的新适应度的平均值<em>F</em>^’^ <del>avg</del> 要等与其原适应度平均值<em>F</em><del>avg</del> 。为了保证群体中适应度接近于平均适应度的个体能够有期待的数量被遗传到下一代群体中</p>
<p>​    2、尺度变换后群体中新的最大适应度<em>F</em>^’^ <del>max</del> 要等与其原平均适应度<em>F</em><del>avg</del> 的指定倍数。即：</p>
<p>​                                                                                                <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532658.png" alt="image-20210415202452162" style="zoom:67%;"></p>
<p>​      式中：C为最佳个体的期望复制数量。对于群体规模大小为50 ~ 100的个体，一般取C=1.2 ~ 2。保证了群体中最好的个体能够期望复制C倍到新一代群体中。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532748.png" alt="image-20210415203028787" style="zoom: 50%;">

<p>​        使用线性尺度变换时，如图所示，群体中<strong>少数几个优良个体的适应度按比例缩小</strong>，同时<strong>几个较差个体的适应度也按比例扩大</strong>。但在搜索过程的后期阶段，随着个体适应度从总体上的不断改进，<strong>群体中个体的最大适应度和全部个体的平均适应度较接近，而少数几个较差的个体的适应度却远远低于最大适应度</strong>，这时若想维持F’<del>max</del>和F<del>avg</del>的指定倍数关系，将有可能会<strong>使较差个体的适应度变换为负值</strong>。这将会给后面的处理过程带来不便，必须避免这种情况的发生。解决这个问题的方法是:<strong>把原最小适应度F<del>min</del>映射为F’<del>min</del>=0，并且保持原平均适应度F<del>avg</del>与新的平均适应度F’<del>avg</del>相等。</strong></p>
</li>
</ul>
<ul>
<li><p>乘幂尺度变换</p>
<p>乘幂尺度变换公式为：F’ = F^k^</p>
<p>​        即新的适应度是原有适应度的某个指定乘幂。幂指数e与所求解的问题有关，并且在算法的执行过程中需要不断对其进行修正才能使尺度变换满足一定的伸缩要求。</p>
</li>
<li><p>指数尺度变换</p>
<p>指数尺度变化公式为：F’ = exp（-βF）</p>
<p>​        即新的适应度是原有适应度的某个指数。式中系数β决定了选择的强制性, β越小，原有适应度较高的个体的新适应度就越与其他个体的新适应度相差较大、亦即越增加了选择该个体的强制性。</p>
</li>
</ul>
<h3 id="选择算子"><a href="#选择算子" class="headerlink" title="选择算子"></a>选择算子</h3><p>​        在生物的遗传和自然进化过程中，对生存环境适应程度较高的物种将有更多的机会遗传到下一代;而对生存环境适应程度较低的物种遗传到下一代的机会就相对较少。模仿这个过程，遗传算法使用<strong>选择算子</strong>(或称复制算子}来对群体中的个体进行优胜劣汰操作:<strong>适应度较高的个体被遗传到下一代群体中的概率较大;适应度较低的个体被遗传到下一代群体中的概率较小</strong>。遗传算法中的选择操作就是用来确定如何<strong>从父代群体中按某种方法选取哪些个体遗传到下一代群体中的一种遗传运算</strong>。</p>
<p>​        选择操作建立在对个体的适应度进行评价的基础之上。选择操作的主要目的是为了避免基因缺失、提高全局收敛性和计算效率。</p>
<p>​        最常用的选揉算子是基本遗传算法中的<strong>比例选择算子</strong>。但对于各种不同的问题，比例选择算子并不是最合适的一种选择算子，所以人们提出了其他一些选择算子。下面介绍几种常用选择算子的操作方法。</p>
<h4 id="比例选择算子"><a href="#比例选择算子" class="headerlink" title="比例选择算子"></a>比例选择算子</h4><p>​        比例选择方法〈Proportionai Model）是一种回放式随机采样的方法。其基本思想是:各个个体被选中的概率与其适应度大小成正比。由于是随机操作的原因，这种选择方法的选择误差比较大，有时甚至连适应度较高的个体也选择不上。</p>
<p>​        设群体大小为M，个体 i 的适应度为F<del>i</del>，则个体 i 被选中的概率为:</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532050.png" alt="image-20210415205035565" style="zoom:50%;">

<p>​        由上式可见，适应度越高的个体被选中的概率也越大;反之，适应度越低的个体被选中的概率也越小。</p>
<p>​        </p>
<h4 id="最优保存策略"><a href="#最优保存策略" class="headerlink" title="最优保存策略"></a>最优保存策略</h4><p>​        我们希望适应度最好的个体要尽可能地保留到下一代群体中。为达到这个目的，可以使用最优保存策略进化模型(Elitist Model)来进行优胜劣汰操作，即当前群体中适应度最高的个体不参与交叉运算和变异运算，而是用它来替换掉本代群体中经过交叉、变异等遗传操作后所产生的适应度最低的个体。</p>
<ul>
<li>最优保存策略进化模型的具体操作过程是:<ul>
<li>(1）找出当前群体中适应度最高的个体和适应度最低的个体。</li>
<li>(2)  若<strong>当前群体中最佳个体的适应度比总的迄今为止的最好个体的适应度还要高</strong>、则以当前群体中的最佳个体作为新的迄今为止的最好个体。</li>
<li>(3) 用<strong>迄今为止的最好个体替换</strong>掉当前群体中的最差个体。</li>
</ul>
</li>
</ul>
<p>​        最优保存策略可视为选择操作的一部分。该策略的实施可保证迄今为止所得到的最优个体不会被交叉、变异等遗传运界所坏<strong>，它是遗传算法收敛性的一个重要保证条件</strong>。但另一方面，它也容易使得某个局部最优个体不易被淘汰掉反而快速扩散，从而<strong>使得算法的全局搜索能力不强</strong>。所以<strong>该方法一般要与其他一些选择操作方法配合起来使用</strong>,方可有良好的效果。</p>
<p>​        另外,最优保存策略还可加以推广，即在每一代的进化过程中保留<strong>多个最优个体不参加交叉、变异</strong>等遗传运算，而直接将它们复制到下一代群体中。这种选择方法也称为稳态复制。</p>
<h4 id="确定式采样选择"><a href="#确定式采样选择" class="headerlink" title="确定式采样选择"></a>确定式采样选择</h4><p>​        确定式采样选择方法（ Deterministic Sampling）的基本思想是按照一种确定的方式来进行选择操作。其具体操作过程是:</p>
<p>​    （1）计算各个个体在下一代群体中的期望生存数目N<del>i</del>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311532105.png" alt="img"></p>
<p>（2）用N<del>i</del>的整数部分<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533448.png" alt="image-20210415211418937" style="zoom:50%;">确定各个对应个体在下一代群体中的生存数目,其中<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533210.png" alt="image-20210415211502451" style="zoom:50%;">表示取不大于x的最大的整数。</p>
<p>由该步共可得出下一代群体中的<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533133.png" alt="image-20210415211532885" style="zoom:50%;">个个体</p>
<p>（3）按照N<del>i</del>的小数部分对个体进行降序排序，顺序取前M -<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533962.png" alt="image-20210415211611550" style="zoom: 33%;">个个体加入下一代群体。至此下一代中的M个个体全部确定出来了。</p>
<p>优点：能够保证适应度较大的一些个体一定能够被保留到下一代群体中。</p>
<h4 id="无回放随机选择"><a href="#无回放随机选择" class="headerlink" title="无回放随机选择"></a>无回放随机选择</h4><p>​        这种选择操作方法也叫做期望值选择方法(Expected Value Model),它的基本思想是根据每个个体在下一代群体中的生存期望值来进行随机选择运算。其具体操作过程是:</p>
<p>(1)  计算群体中每个个体在下一代群体中的生存期望数目N<del>i</del> :<br>                                                                <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533056.png" alt="image-20210415212202462" style="zoom: 50%;"><br>(2）若某一个体被选中参与交叉运算,则它在下一代中的生存期望数目减去0.5,若某一个体未被选中参与交叉运算,则它在下一代中的生存期望数目减去1.0。<br>(3）随着选择过程的进行,若某一个体的生存期望数目小于0时，则该个体就不再有机会被选中。</p>
<p>这种选择操作方法能够降低一些选择误差,但操作不太方便。</p>
<h4 id="无回放余数随机选择"><a href="#无回放余数随机选择" class="headerlink" title="无回放余数随机选择"></a>无回放余数随机选择</h4><p>具体操作过程：</p>
<p>（1）计算群体中每个个体在下一代群体中的生存期望数目N<del>i</del> :<br>                                                                <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533146.png" alt="image-20210415212202462" style="zoom: 50%;"></p>
<p>（2）用N<del>i</del>的整数部分<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533085.png" alt="image-20210415211418937" style="zoom:50%;">确定各个对应个体在下一代群体中的生存数目,其中<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533931.png" alt="image-20210415211502451" style="zoom:50%;">表示取不大于x的最大的整数。</p>
<p>由该步共可得出下一代群体中的<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533140.png" alt="image-20210415211532885" style="zoom:50%;">个个体</p>
<p>（3）以<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311533771.png" alt="image-20210415212826324" style="zoom:50%;">为各个个体的新的适应度,用比例选择方法(赌盘选择方法）来随机确定下一代群体中还未确<br>定的<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311534676.png" alt="image-20210415212903511" style="zoom: 50%;">个个体。</p>
<h4 id="排序选择"><a href="#排序选择" class="headerlink" title="排序选择"></a>排序选择</h4><p>​        在前面的一些选择操作方法中,其选择依据主要是各个个体适应度的具体数值,一般要求它取非负值,这就使得我们在选择操作之前必须先对一些负的适应度进行变换处理。而排序选择方法(Rank-based Model)的主要着眼点是个体适应度之间的大小关系,对个体适应度是否取正值或负值以及个体适应度之间的数值差异程度并无特别要求。</p>
<p>​    排序选择方法的主要思想是:对群体中的所有个体按其<strong>适应度大小进行排序</strong>,基于这个排序来分配各个个体被选中的概率。其具体操作过程是:</p>
<p>​    (1〉对群体中的所有个体按其适应度大小进行<strong>降序排序</strong>。</p>
<p>​    (2）根据具体求解问题,<strong>设计一个概率分配表,将各个概率值按上述排列次序分配给各个个体</strong>。<br>​    (3)  以各个个体所分配到的概率值作为其能够被遗传到下一代的概率,基于这些概率值<strong>用比例选择(赌盘选择)的方法来产生下一代群体</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311534337.png" alt="image-20210415214945020" style="zoom:50%;">

<p>由于具体选中哪一个个体仍是使用了随机性较强的比例选择方法,所以排序选择方法仍具有较大的选择误差。</p>
<h4 id="随机联赛选择"><a href="#随机联赛选择" class="headerlink" title="随机联赛选择"></a>随机联赛选择</h4><p>​        随机联赛选择( Stochastic Tournament Model)是一种基于个体适应度之间大小关系的选择方法。其基本思想是每次选取几个个体之中<strong>适应度最高</strong>的一个个体遗传到下一代群体中。在联赛选择操作中,<strong>只有</strong>个体适应度之间的<strong>大小比较运算</strong>,而<strong>无</strong>个体适应度之间的<strong>算术运算</strong>,所以它对个体适应度是取正值还是取负值无特别要求。<br>​        联赛选择中,每次进行适应度大小比较的个体数目称为联赛规模。一般情况下,联赛规模N的取值为2。<br>​        联赛选择的具体操作过程是:<br>​        (1）从群体中随机选取N个个体进行适应度大小的比较,将其中适应度最高的个体遗传到下-代群体中。<br>​        (2)  将上述过程重复M次,就可得到下一代群体中的M个个体。</p>
<h3 id="交叉算子"><a href="#交叉算子" class="headerlink" title="交叉算子"></a>交叉算子</h3><p>​        遗传算法中的所谓<strong>交叉运算</strong>,是指对两个相互配对的染色体按某种方式相互交换其部分基因,从而形成两个新的个体。交叉运算是遗传算法区别于其他进化算法的重要特征,它在遗传算法中起着关键作用,是<strong>产生新个体的主要方法</strong>。</p>
<p>​        遗传算法中,在交叉运算之前还必须先对群体中的个体进行配对。吕前常用的配对策略是<strong>随机配对</strong>,即将群体中的M个个体以随机的方式组成<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311534383.png" alt="image-20210416094522022" style="zoom:50%;">对配对个体组,交叉操作是在这些配对个体组中的两个个体之间进行的。</p>
<ul>
<li><p>交叉算子的设计包括以下两方面的内容:</p>
<ul>
<li>(1）如何确定交叉点的位置?</li>
<li>(2）如何进行部分基因交换?</li>
</ul>
<p>最常用的交叉算子是单点交叉算子，但有一点的适用范围。还有几种适合二进制编码个体或浮点数编码个体的交叉算子</p>
<p>交叉变化可以这样理解：<strong>每设置一个交叉点，该交叉点之后的所有基因都需要进行交换。若存在多个交叉点，则奇数交叉点与下一个偶数交叉点的基因需要进行交换，偶数交叉点与下一个奇数交叉点之间的基因不需要进行交换。</strong></p>
</li>
</ul>
<h4 id="单点交叉"><a href="#单点交叉" class="headerlink" title="单点交叉"></a>单点交叉</h4><p>​        单点交叉(One-point Crossover)又称为简单交叉，它是指在个体编码串中只<strong>随机设置一个交叉点</strong>,然后在该点相互交换两个配对个体的<strong>部分染色体</strong>。</p>
<p>​        单点交叉的重要<strong>特点</strong>是:若邻接基因座之间的关系能提供较好的个体性状和较高的个体适应度的话,则这种单点交叉操作破坏这种个体性状和降低个体适应度的可能性<strong>最小</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311534577.gif" alt="单点交叉"></p>
<h4 id="双点交叉与多点交叉"><a href="#双点交叉与多点交叉" class="headerlink" title="双点交叉与多点交叉"></a>双点交叉与多点交叉</h4><p>​        双点交叉(Two–point Crossover)是指在个体编码串中随机设置了二个交叉点,然后再进行部分基因交换。</p>
<ul>
<li>双点交叉的具体操作过程是:<ul>
<li>(1）在相互配对的两个个体编码串中随机设置两个交叉点。</li>
<li>(2)  交换两个个体在所设定的两个交叉点之间的部分染色体。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311534563.gif" alt="双点交叉"></p>
<p>​        多点交叉是指在个体编码串中随机设置了多个交叉点,然后进行基因交换。多点交叉又称为广义交叉,其操作过程与单点交叉和双点交叉相类似。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311534170.png" alt="image-20210416102713426" style="zoom: 67%;">

<p>​        需要说明的是，<strong>一般不太使用多点交叉算子</strong>,因为它有可能破坏一些好的模式。事实上，随着交叉点数的增多,个体的结构被破<br>坏的可能性也逐渐增大，这样就很难有效地保存较好的模式，从而影响遗传算法的性能。</p>
<h4 id="均匀交叉"><a href="#均匀交叉" class="headerlink" title="均匀交叉"></a>均匀交叉</h4><p>​        均匀交叉(Uniform Crossover)是指两个配对个体的每-一个基因座上的基因都以相同的交叉概率进行交换，从而形成两个新的个体，均匀交叉实际上可归属于多点交叉的范围,其具体运算可通过设置一屏蔽字来确定新个体的各个基因如何由哪一个父代个体来提供。均匀交叉的主要操作过程如下:</p>
<p>​    (1）随机产生一个与个体编码串长度等长的屏蔽字W = w<del>1</del>w<del>2</del>… w<del>l</del>，其中l为个体编码串长度。<br>​    (2）由下述规则从A、B两个父代个体中产生出两个新的子代个体A’、B’:<br>​        ● 若w<del>i</del> = 0，则 A’ 在第i个基因座上的基因值继承A的对应基因值，B’ 在第 i 个基因座上的基因值继承B的对应基因值;<br>​        ● 若w<del>i</del> = 1，则A‘ 在第i个基因座上的基因值继承B的对应基因值，B’ 在第 i 个基因座上的基因值继承A的对应基因值。<br>均匀交又操作的示例如下:</p>
<p>​                                <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311534474.png" alt="image-20210416103535567" style="zoom: 67%;"></p>
<h4 id="算术交叉"><a href="#算术交叉" class="headerlink" title="算术交叉"></a>算术交叉</h4><p>​        算术交叉(Arithmetic Crossover）是指由两个个体的线性组合而产生出两个新的个体。为了能够进行线性组合运算，<strong>算术交叉的操作对象一般是由浮点数编码所表示的个体</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311535747.png" alt="image-20210416103930687" style="zoom: 67%;">

<p>式中,α为一参数,它可以是一个常数,此时所进行的交叉运算称为均匀算术交叉;它也可以是一个由进化代数所决定的变量,此时所进行的交叉运算称为非均匀算术交叉。</p>
<ul>
<li>算术交叉的主要操作过程是：<ul>
<li>(1) 确定两个个体进行线性组合时的系数α 。</li>
<li>(2）依据式(3-14)生成两个新的个体。</li>
</ul>
</li>
</ul>
<h4 id="POX交叉算子"><a href="#POX交叉算子" class="headerlink" title="POX交叉算子"></a>POX交叉算子</h4><p>POX(precedence operation crossover)交叉算子得到的子代总是可行的。染色体p1 和p2 交叉生成两个子代c1 和c2，交叉过程如下：1）随机划分工件集为两个非空子集J1 和J2；</p>
<p>2）复制p1中属于工件集J1 中工件的工序到c1，复制p2中属于工件集J1 中工件的工序到c2，保留它们的位置；</p>
<p>3）复制p1中属于工件集J2 中工件的工序到c2，复制p2中属于工件集J2 中工件的工序到c1，保留它们的顺序。</p>
<p>同时复制对应位置的机器号; 最后从子代中随机选择 1 个作为后代.</p>
<p>POX 交叉过程使后代保留了部分工件在机器上的位置, 并使子代继承父代在每台机器上工序的次序, 具有很好的保优作用, 同时从交叉后的 2 个粒子中随机选择 1 个作为后代, 从而保持了种群的多样性.</p>
<p>下图展示了一次交叉过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311535449.png" alt="img"></p>
<h4 id="RPX-交叉算子"><a href="#RPX-交叉算子" class="headerlink" title="RPX 交叉算子"></a>RPX 交叉算子</h4><p>𝑔(𝐹𝑘𝑖, 𝑝𝐵𝑘𝑖) 表示针对 𝐵 向量的 RPX 交叉算子,操作过程如下:</p>
<p>​        随机产生由 (0, 1) 区间小数构成的数组 𝑅, 𝑅 的长度与粒子<strong>维数相等</strong>。若数组 𝑅 中的随机数小于 𝑝 (𝑝∈(0, 1))，则复制 𝑝𝐵𝑘𝑖对应工序的机器号到 𝐹𝑘𝑖。其中 <strong>𝑝 = 𝑝max−[(𝑝max−𝑝min)/iter]∗gen</strong>，iter 为迭代次数，gen 为当前运行代数。该方法相对于传统基于位置的交叉方法，可<strong>根据所需情况控制交叉的概率，𝑝 的自适应调整有利于在全局范围内产生更好的搜索能力</strong>，<strong>进化后期加强局部搜索能力</strong>，对提高获取最优解的概率有一定的帮助。</p>
<h4 id="FRG-Fragment-reordering-crossover-算子"><a href="#FRG-Fragment-reordering-crossover-算子" class="headerlink" title="FRG (Fragment reordering crossover) 算子"></a>FRG (Fragment reordering crossover) 算子</h4><p>​        FRG程序可被视为位置和顺序交叉的反向版本的特殊情况。首先，来自P1的所有元素被复制到CH的相同位置。然后CH中随机片段的所有元素按照它们在P2出现的顺序在这个片段中重新分配。可以看到，在CH解中，片段内的任何元素(无论它在这个片段中的分配如何)和片段外的所有元素之间的优先关系都是从P1继承的。片段中的优先关系继承自P2。因此，如果P1和P2是可行序列，CH继承了这种可行性。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311540322.png" alt="image-20211124191109001" style="zoom: 67%;">

<h4 id="WMX-weight-mapping-crossover-，基于两点的权重映射交叉-算子"><a href="#WMX-weight-mapping-crossover-，基于两点的权重映射交叉-算子" class="headerlink" title="WMX(weight mapping crossover ，基于两点的权重映射交叉)算子"></a>WMX(weight mapping crossover ，基于两点的权重映射交叉)算子</h4><p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311536630.png" alt="image-20211122210741103"></p>
<h3 id="变异算子"><a href="#变异算子" class="headerlink" title="变异算子"></a>变异算子</h3><p>​        遗传算法中的所谓变异运算，是指将个体染色体编码串中的某些基因座上的基因值<strong>用该基因座的其他等位基因来替换</strong>，从而形成一个新的个体。例如，对于二进制编码的个体,其编码字符集为{0，1}，变异操作就是将<strong>个体在变异点上的基因值取反</strong>，即用0替换1，或用1替换0；对于浮点数编码的个体，若某一变异点处的基因值的取值范围为[Umin，Umax]，变异操作就是用<strong>该范围内的一个随机数</strong>去替换原基因值；对于符号编码的个体,若其编码字符集为{A，B，C,…}，变异操作就是用这个<strong>字符集中的一个随机指定的且与原基因值不相同的符号</strong>去替换变异点上的原有符号。</p>
<p>​        从遗传运算过程中产生新个体的能力方面来说，<strong>交叉运算是产生新个体的主要方法</strong>，它决定了遗传算法的<strong>全局搜素能力</strong>；而变异运算只是产生新个体的辅助方法，但它也是必不可少的一个运算步骤，因为它决定了遗传算法的<strong>局部搜索能力</strong>。交叉算子与变异算子的相互配合，共同完成对搜索空间的全局搜索和局部搜索，从而使得遗传算法能够以良好的搜索性能完成最优化同题的寻优过程。</p>
<ul>
<li><p>使用变异算子主要的两个目的：</p>
<ul>
<li>(1）<strong>改善遗传算法的局部搜索能力</strong>。遗传算法使用交叉算子已经从全局的角度出发找到了一些较好的个体编码结构，它们已接近或有助于接近问题的最优解。但仅使用交叉算子无法对搜索空间的细节进行局部搜索。这时若再使用变异算子来调整个体编码串中的部分基因值，就可以从局部的角度出发使个体更加逼近最优解，从而提高了遗传算法的局部搜索能力。</li>
<li>(2）<strong>维持群体的多样性,防止出现早熟现象</strong>。变异算子用新的基因值替换原有基因值，从而可以改变个体编码串的结构，维持群体的多样性，这样就有利于防止出现早熟现象。</li>
</ul>
</li>
<li><p>变异算子的设计包括如下两方面的内容:</p>
<ul>
<li>（1）如何确定变异点的位置?</li>
<li>（2）如何进行基因值替换?</li>
</ul>
</li>
</ul>
<h4 id="基本位变异"><a href="#基本位变异" class="headerlink" title="基本位变异"></a>基本位变异</h4><p>​        基本位变异(Simple Mutation)操作是指对个体编码串中<strong>以变异概率p<del>m</del>随机指定的某一位或某几位基因座上的基因值作变异运算</strong>。<br>​        基本位变异操作改变的只是个体编码串中的个别几个基因座上的基因值,并且变异发生的概率也比较小,所以其发挥的作用比较慢,作用的效果也不明显。</p>
<h4 id="均匀变异"><a href="#均匀变异" class="headerlink" title="均匀变异"></a>均匀变异</h4><p>​        均匀变异(Uniforrn Mutation）操作是指分别用符合某一范围内均匀分布的随机数，以某一较小的概率来替换个体编码串中各个基因座上的原有基因值。</p>
<ul>
<li><p>均匀变异的具体操作过程是:</p>
<ul>
<li><p>(1）依次指定个体编码串中的每个基因座为变异点。</p>
</li>
<li><p>(2)  对每一个变异点,以变异概率pm从对应基因的取值范围内取一随机数来替代原有基因值。</p>
</li>
</ul>
</li>
</ul>
<p>​        假设有一个体为X = x<del>1</del>x<del>2</del>… x<del>k</del>…x<del>l</del>，若x<del>k</del>为变异点，其取值范围为[ U^k^ <del>min</del>，U^k^ <del>max</del>]。在该点对个体X进行均匀变异操作后，可得到一个新的个体X’ = x<del>1</del>x<del>2</del>… x‘<del>k</del>…x<del>l</del>，其中变异点的新基因值是:<br>​                                                                      <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311536296.png" alt="image-20210416111544498" style="zoom: 80%;"></p>
<p>​        式中，r为[0，1]范围内符合均匀概率分布的一个随机数。<br>​        均匀变异操作特别适合应用于遗传算法的初期运行阶段，它使得搜索点可以在整个搜索空间内自由地移动,从而可以增加群体的多样性,使算法处理更多的模式。</p>
<h4 id="边界变异"><a href="#边界变异" class="headerlink" title="边界变异"></a>边界变异</h4><p>​        边界变异(Boundary Mutation)操作是上述均匀变异操作的一个变形遗传算法。在进行边界变异操作时，随机地取基因座的二个对应边界基因值之一去替代原有基因值。</p>
<p>​        在进行由X=  x<del>1</del>x<del>2</del>… x<del>k</del>…x<del>l</del>  向 X’ = x<del>1</del>x<del>2</del>… x‘<del>k</del>…x<del>l</del>  的边界变异操作时，若变异点x<del>k</del>处的基因值取值范围为[U^k^ <del>min</del>，U^k^ <del>max</del>]，则新的基因值x’<del>k</del> 由下式确定：</p>
<p>​                                                                    <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311536877.png" alt="image-20210416112250165" style="zoom: 67%;"></p>
<h4 id="非均匀变异"><a href="#非均匀变异" class="headerlink" title="非均匀变异"></a>非均匀变异</h4><p>​        <strong>均匀变异</strong>操作取某一范圉内均匀分布的随机数来替换原有基达值，可使得个体在搜索空间内自由移动。但另一方面，<strong>它却不便于对某一重点区域进行局部搜索</strong>。为改进这个性能，我们不是取均匀分布的随机数去替换原有的基因值，而是<strong>对原有基因值作一随机扰动</strong>，以扰动后的结果作为变异后的新基因值。对每个基因座都以相同的概率进行变异运算之后，相当于整个解向量在解空间中作了一个轻微的变动。这种变异操作方法就称为非均匀变异(Non-uniform Mutation)。</p>
<p>​        非均习变异的具体操作过程与均匀变异相类似，但它<strong>重点搜索原个体附近的微小区域</strong>。</p>
<p>​        在进行由X=  x<del>1</del>x<del>2</del>… x<del>k</del>…x<del>l</del>  向 X’ = x<del>1</del>x<del>2</del>… x‘<del>k</del>…x<del>l</del>  的边界变异操作时，若变异点x<del>k</del>处的基因值取值范围为[U^k^ <del>min</del>，U^k^ <del>max</del>]，则新的基因值x’<del>k</del> 由下式确定：</p>
<p>​                                                    <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311537853.png" alt="image-20210416113415783" style="zoom: 67%;"></p>
<p>式中，△(t，y) ( y 代表U^k^ <del>max</del> - v<del>k</del> 和 v<del>k</del>  - U^k^ <del>max</del> ) 表示[0，y]范围内符合非均匀分布的一个随机数，要求随着进化代数t的增加，△( t ，y)接近于0的概率也逐渐增加。例如,△(t,y)可按下式定义:</p>
<p>​                                                            <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311537414.png" alt="image-20210416113838851" style="zoom:80%;"></p>
<p>​        式中, r为[0，1]范围内符合均匀概率分布的一个随机数，T是最大进化代数，b是一个系统参数，它决定了随机扰动对进化代数t的依赖程度。<br>​        由上式可知，<strong>非均匀变异可使得遗传算法在其初始运行阶段(t较小时)进行均匀随机搜索</strong>，而在其后期运行阶段**(z较接近于T时)进行局部搜索**，所以它产生的新基因值比均匀变异所产生的基因值更接近于原有基因值。故随着遗传算法的运行，非均匀变异就使得最优解的搜索过程更加集中在某一最有希望的重点区域中。</p>
<h4 id="高斯变异"><a href="#高斯变异" class="headerlink" title="高斯变异"></a>高斯变异</h4><p>​        高斯变异(Gaussian Mutation)是改进遗传算法对重点搜索区域的局部搜索性能的另一种变异操作方法。所谓高斯变异操作是指进行变异操作时，用<strong>符合均值为u、方差为σ^2^的正态分布的一个随机数来</strong>替换原有基因值。<br>​        具体实现高斯变异时，符合正态分布的随机数Q可由一些符合均匀分布的随机数利用公式来近似产生。假定有12个在[0，1]范围内均匀分布的随机数r<del>i</del>  ( i = 1,2,…,12),则符合N(u，σ^2^)正态分布的一个随机数Q可由下式求得:</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311537149.png" alt="image-20210416114550726" style="zoom:80%;">

<p>​        在进行由X=  x<del>1</del>x<del>2</del>… x<del>k</del>…x<del>l</del>  向 X’ = x<del>1</del>x<del>2</del>… x‘<del>k</del>…x<del>l</del>  的边界变异操作时，若变异点x<del>k</del>处的基因值取值范围为[U^k^ <del>min</del>，U^k^ <del>max</del>]，则新的基因值x’<del>k</del> 由下式确定：</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311537615.png" alt="image-20210416114625859" style="zoom:80%;">

<p>则新的基因型x’<del>k</del>可由下式确定：</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311537726.png" alt="image-20210416114716402" style="zoom:67%;">



<h4 id="实际问题变异算子"><a href="#实际问题变异算子" class="headerlink" title="实际问题变异算子"></a>实际问题变异算子</h4><p>装配优先图如图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311537608.png" alt="image-20211124192039908" style="zoom: 67%;">

<p>变异算子如下：</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311542002.png" alt="image-20211124192110130" style="zoom:50%;">







<h3 id="遗传算法的运行参数"><a href="#遗传算法的运行参数" class="headerlink" title="遗传算法的运行参数"></a>遗传算法的运行参数</h3><p>​        遗传算法中需要选择的运行参数主要有<strong>个体编码串长度l、群体大小M、交叉概率pc、变异概率pm、终止代数T、代沟G</strong>等。这些参数对遗传算法的运行性能影响较大，需认真选取。</p>
<ul>
<li><p><strong>编码串长度l</strong>使用二进制编码来表示个体时，编码串长度l的选取与问题所要求的求解精度有关；使用浮点数编码来表示个体时，编码串长度l与决策变量的个数n相等；使用符号编码来表示个体时，编码串长度l由问题的编码方式来确定；另外，也可使用变长度的编码来表示个体。</p>
</li>
<li><p><strong>群体大小M</strong>：群体大小M表示群体中所含个体的数量。当M取值较小时，可提高遗传算法的运算速度，但却降低了群体的多样性，有可能会引起遗传算法的早熟现象；而当M取值较大时，又会使得遗传算法的运行效率降低。一般<strong>建议的取值范围是20 ~100</strong>。</p>
</li>
<li><p><strong>交叉概率pc</strong>：交叉操作是遗传算法中产生新个体的主要方法，所以<strong>交叉概率一般应取较大值</strong>。但若取值过大的话，它又会破坏群体中的优良模式，对进化运算反而产生不利影响；若取值过小的话，产生新个体的速度又较慢。一般<strong>建议的取值范围是0.4~0.99</strong>。另外，也可<strong>使用自适应的思想来确定交叉概率pc</strong>，随着遗传算法在线性能的提高，可以增大交叉概率pc的取值。</p>
</li>
<li><p><strong>变异概率pm</strong>：若变异概率pm取值较大的话，虽然能够产生出较多的新个体，但也有可能破坏掉很多较好的模式，使得遗传算法的性能近似于随机搜索算法的性能；若变异概率pm取值太小的话，则变异操作产生新个体的能力和抑制早熟现象的能力就会较差。一般<strong>建议的取值范围是0.0001~- 0.1</strong>。另外，也可<strong>使用自适应的思想来确定变异概率pm</strong>，随着遗传算法在线性能的下降，可以减小变异概率pm的取值；Whitley提出一种自适应变异策略，<strong>pm与其上一代群体间的海明距离成反比</strong>，其结果显示出这种方法能够有效地维持群体的多样性。</p>
</li>
<li><p><strong>终止代数T</strong>：终止代数T是表示遗传算法运行结束条件的一个参数，它表示遗传算法运行到指定的进化代数之后就停止运行，并将当前群体中的最佳个体作为所求问题的最优解输出。一般<strong>建议的取值范围是100 – 1000</strong>。</p>
<p>常用的判定准则：</p>
<ul>
<li>连续几代个体<strong>平均适应度的差异</strong>小于某一个极小的阈值;</li>
<li>群体中所有<strong>个体适应度的方差</strong>小于某一个极小的阚值。</li>
</ul>
</li>
<li><p><strong>代沟G</strong>：代沟G是表示各代群体之河个体重叠程度的一个参数，它表示每一代群体中被替换掉的个体在全部个体中所占的百分率，即每一代群体中有（M× G）个个体被替换掉。例如，G=1.0表示群体中的全部个体都是新产生的,这也是最常见的一种情况；G = 0.7则表示70%的个体是新产生的，而随机保留了上一代群体中30%的个体。</p>
</li>
</ul>
<h3 id="约束条件的处理方法"><a href="#约束条件的处理方法" class="headerlink" title="约束条件的处理方法"></a>约束条件的处理方法</h3><h4 id="搜索空间限定法"><a href="#搜索空间限定法" class="headerlink" title="搜索空间限定法"></a>搜索空间限定法</h4><p>​        这种处理方法的基本思想是对遗传算法的搜索空间的大小加以限制，使得搜索空间中表示一个个体的点与解空间中表示一个可行解的点有一一对应的关系。此时的搜索空间与解空间的对应关系如图所示。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311542598.png" alt="image-20210416191439125" style="zoom:50%;">

<p>​        对一些比较简单的约束条件(如a≤ x ≤b之类)，<strong>在个体染色体的编码方法上着手</strong>，就能够达到这种搜索空间与解空间之间的一一对应的要求。用这种处理方法能够在遗传算法中设置最小的搜索空间，所以它能够提高遗传算法的搜索效率。但需要注意的是，除了在编码方法上想办法之外，也<strong>必须保证经过交叉、变异等遗传算子作用之后所产生出的新个体在解空间中也要有确定的对应解</strong>，而不会产生无效解。</p>
<p>​        有两种方法实现：</p>
<ul>
<li><p>方法一：用编码方法来保证总是能够产生出在解空间中有对应可行解的染色体。</p>
<p>这个实现方法要求我们设计出一种比较好的个体编码方案。例如，在处理a≤ x ≤b这样的约束条件时，若使用二进制编码串来表示个体，我们将区间[a , b]划分为(2^l^ - 1)个等分 ( 其中l为个体编码串长度 )，<strong>δ为每个等分的长度</strong>，并且使编码时的对应关系如下:</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311538169.png" alt="image-20210416192947766" style="zoom: 80%;"></li>
<li><p>方法二：用程序来保证直到产生出在解空间中有对应可行解的染色体之前，一直进行交叉运算和变异运算。</p>
<p><strong>对编码方法要求不高，但可能会降低遗传算法的效率</strong></p>
</li>
</ul>
<h4 id="可行解变换法"><a href="#可行解变换法" class="headerlink" title="可行解变换法"></a>可行解变换法</h4><p>​        这种处理方法的基本思想是：<strong>在由个体基因型到个体表现型的变换中，增加使其满足约束条件的处理过程</strong>。即寻找出一种<strong>个体基因型和个体表现型之间的多对一</strong>的变换关系，使进化过程中所产生的个体总能够通过这个变换而转化成解空间中满足约束条件的一个可行解。                                                                        <img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311543365.png" alt="image-20210416193358695" style="zoom: 67%;"></p>
<p>​        这种处理方法虽然对个体的编码方法、交叉运算、变异运算等没有附加的要求，但它却是以扩大搜索空间为代价的，所以一般会使得<strong>遗传算法的运行效率有所下降</strong>。</p>
<h4 id="罚函数法"><a href="#罚函数法" class="headerlink" title="罚函数法"></a>罚函数法</h4><p>​        这种处理方法的基本思想是：对在解空间中无对应可行解的个体，计算其适应度时，处以一个罚函数，从而降低该个体适应度，使该个体被遗传到下一代群体中的机会减少。即用下式来对个体的适应度进行调整:</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311543093.png" alt="image-20210416194224942" style="zoom:67%;">

<img src="/.io//笔记\论文笔记\论文笔记.assets\image-20210416194359219.png" alt="image-20210416194359219" style="zoom: 67%;">



<h2 id="遗传算法的高级实现技术"><a href="#遗传算法的高级实现技术" class="headerlink" title="遗传算法的高级实现技术"></a>遗传算法的高级实现技术</h2><h3 id="倒位算子"><a href="#倒位算子" class="headerlink" title="倒位算子"></a>倒位算子</h3><h4 id="到位操作"><a href="#到位操作" class="headerlink" title="到位操作"></a>到位操作</h4><p>​        所谓倒位操作(Inverse Operation)是指颠倒个体编码串中随机指定的二个基因座之间的基因排列顺序，从而形成一个新的染色体。倒位操作的具体过程是:</p>
<ul>
<li><p>(1)  在个体编码串中随机指定二个基因座之后的位置为倒位点;</p>
</li>
<li><p>(2）以倒位概率p<del>i</del> <strong>颠倒这二个倒位点之间的基因排列顺序</strong>。</p>
<p>如下所示为对二进制编码个体进行倒位操作的示例:</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311543631.png" alt="image-20210416195127811"></p>
<p>​        倒位操作改变了个体编码串的部分基因排列顺序，其目的主要是为了能够使遗传算法更有利于生成较好的模式。<strong>因为有时对形成一种较好的模式有积极意义的基因在个体的编码串中隔离得较远,而使用倒位算子就有可能使它们逐渐接近,从而可能形成更好的个体</strong>。</p>
<p>​        如何理解：</p>
<p>​        为正确地进行解码和自由地表示个体，我们可以给每个基因取一个名称，这个名称可以用整数来代表，也可以用符号来表示。例如,如下所示为个体的基因型以及各个基因的名称示例:</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311543984.png" alt="image-20210416195536139" style="zoom:67%;">

<p>​        在指定的倒位位置对上面这个个体进行倒位操作之后，可得到一个新的个体，如下所示：</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311543604.png" alt="image-20210416195615537" style="zoom:67%;">

<p>​        使用这种扩展了的带有基因名称的个体编码方式，可使得<strong>各个编码值(基因值)保持其原有的意义或权</strong>，而<strong>与其在串中的位置无关</strong>，比如，名称为H的基因的含义是固定不变的，而不管其在编码串巾的哪个位置。这样做的结果是：若仅使用倒位算子，将不会对个体编码串的译码结果有任何影响，所以不会改变个体的特性值。也就是说，,倒位操作改变的<strong>仅是个体编码的结构形式</strong>，而不改变其特性。但是，<strong>个体编码串的结构形式却对该个体的适应度有着重要的影响</strong>。</p>
<h4 id="倒位算子的应用实例"><a href="#倒位算子的应用实例" class="headerlink" title="倒位算子的应用实例"></a>倒位算子的应用实例</h4><p>以栅格内移动机器人路径规划为例，说明移位算子的作用：</p>
<p>如图所示为-一移动机器人的2维规划空间，整个空间依据机器人的尺寸被划分为一块—块的栅格，每个栅格有一标号，图中带有阴影的栅格表示障碍物，S为机器人行走路线的起点，G为终点。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311543665.png" alt="image-20210416195936600" style="zoom:80%;">

<p>​        用遗传算法进行机器人路径规划时，可取机器人移动过程中所经过栅格标号的顺序排列来作为一个个体(一条行走路线)的表现形式，如下所示即表示一条行走路线：<br>​        PATH：0—3—9—13—29—39.（虚线所示路线)<br>​        若在上述行走路线的第二个路径点和第三个路径点之间进行倒位操作，则可得到一条新的行走路线：<br>​        PATH：0—9—3—13—29—39.（实线所示路线)<br>​        如果以路径长短作为路径优劣的评价准则的话,显然新的行走路线比原有行走路线要好。</p>
<h3 id="二倍体与显性操作算子"><a href="#二倍体与显性操作算子" class="headerlink" title="二倍体与显性操作算子"></a>二倍体与显性操作算子</h3><p>​        二倍体结构中各个基因有显性基因(Dominance Gene)和隐性基因(Recessive Gene)之分，这二类基因使个体所呈现出的表现型由下述规则来决定：在每个基因座上，当两个同源染色体其中之一的基因是显性时，则该基因所对应的性状表现为显性；而仅当两个同源染色体中对应基因皆为隐性时，该基因所对应的性状才表现为隐性。</p>
<p>​        二倍体结构提供了一种机制，它<strong>记忆以前有用的基因及基因组合</strong>；而显性提供了一种算子，<strong>它保护所记忆的基因，免受有害选择运算所破坏</strong>。这种解释揭示了二倍体的条重要特性，有明显的应用意义。</p>
<ul>
<li>一是<strong>二倍体的记忆能力</strong>，它使得生物能够记忆以前所经历过的环境及变化，使得生物的遗传进化过程能够快速地适应环境的变化。这个特点在遗传算法中的应用意义就在于，使用二倍体结构的遗传算法能够<strong>解决动态环境下的复杂系统优化问题</strong>，而常规的遗传算法却不能很好地应用于动态环境，它难于跟踪环境的动态变化过程。</li>
<li>二是<strong>显性操作的鲁棒性</strong>，它使得即使随机选择了适应度不高的个体，而在显性操作的作用下，能够用其另一同源染色体对其进行校正，从而避免这个有害选择所带来的不利之处。这个特点应用于遗传算法中，能<strong>有利于提高遗传算法的运算效率，维护好的搜索群体。</strong></li>
</ul>
<p>​        对于静态优化问题，与使用单倍体的遗传算法相比，使用双倍体的遗传算法并不能改善多少求解性能。但对于动态系统的优化饲题，使用单倍体的遗传算法很难达到优化要求，因为它跟踪不了动态环境的变化过程，此时，使用双倍体的遗传算法却能表现出较好的应用效果。</p>
<h2 id="Harmony-Search-HS-算法"><a href="#Harmony-Search-HS-算法" class="headerlink" title="Harmony Search(HS)算法"></a>Harmony Search(HS)算法</h2><p>​        和声搜索算法（Harmony Search，HS），在和声练习时，指挥者通过各个乐器的音调，来让和声达到最好的“美学评价”的和声，我们称为“极好的和声”。通过一次次联系，指挥者找到“极好的和声”的过程就是一次寻找最优解的过程。</p>
<p>​        因此，我们将乐队练习的过程抽象成智能优化的过程。“不同的乐器”可以看做不同的变量值，“美学评价”就是目标函数，“极好的和声”即为“全局最优”，“一次次练习”是“迭代运算”。</p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311543058.png" alt="image-20220104200725623" style="zoom:67%;">



<h3 id="和声搜索算法的原理及结构"><a href="#和声搜索算法的原理及结构" class="headerlink" title="和声搜索算法的原理及结构"></a>和声搜索算法的原理及结构</h3><ul>
<li><p>过程：1.初始化和声记忆库</p>
<p>​            2.随机产生新的和声</p>
<p>​            3.如果新的和声比记忆库中最差的和声好，则用新的替换掉最差的</p>
<p>​            4.循环迭代</p>
</li>
</ul>
<h3 id="和声记忆库保留概率（HMCR）"><a href="#和声记忆库保留概率（HMCR）" class="headerlink" title="和声记忆库保留概率（HMCR）"></a>和声记忆库保留概率（HMCR）</h3><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311544290.png" alt="image-20220104201529967" style="zoom: 67%;">

<h3 id="音调调节率（PAR）"><a href="#音调调节率（PAR）" class="headerlink" title="音调调节率（PAR）"></a>音调调节率（PAR）</h3><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311544728.png" alt="image-20220104201732134" style="zoom:67%;">



<h3 id="和声搜索算法的主要步骤与流程"><a href="#和声搜索算法的主要步骤与流程" class="headerlink" title="和声搜索算法的主要步骤与流程"></a>和声搜索算法的主要步骤与流程</h3><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311544777.png" alt="image-20220104202102746" style="zoom:67%;">

<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311544064.png" alt="image-20220104202917828" style="zoom:67%;">

<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311545058.png" alt="image-20220104203128110" style="zoom: 67%;">

<p><strong>注意：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311545726.png" alt="image-20220104203155420" style="zoom:67%;">

<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311545011.png" alt="image-20220104203327867"></p>
<h1 id="遗传算法实现JSP优化"><a href="#遗传算法实现JSP优化" class="headerlink" title="遗传算法实现JSP优化"></a>遗传算法实现JSP优化</h1><h2 id="Matlab生成JSP的GA编码"><a href="#Matlab生成JSP的GA编码" class="headerlink" title="Matlab生成JSP的GA编码"></a>Matlab生成JSP的GA编码</h2><p>Step1:决定编码的长度和内容，长度=n*m,内容=1、2、…、n，这些数值出现m次，一维数组；对应的函数:<strong>createChrome(jobQty,machQty)</strong></p>
<p>Step2:将有规律的编码乱序排列，使用randperm函数</p>
<p>Step3:根据输入的参数pop来生成多个编码，形成算法的初始种群，结果：二维数组，每行表示一个编码**[一个可行解]<strong>,列为step1生成的随机编码，对应函数</strong>createChromes(jobQty,machQty,pop)**</p>
<h2 id="根据编码生成具体调度方案"><a href="#根据编码生成具体调度方案" class="headerlink" title="根据编码生成具体调度方案"></a>根据编码生成具体调度方案</h2><p>Step1：初始化数据-工时设备数据data，编码chrome</p>
<p>​                另外，将data奇数列设备编码由原来的0开始，转换为从1开始</p>
<p>Step2：将编码转换为具体调度方案</p>
<p>​                Step2.1：定义一个jobQty*machQty行，5列的二维数组[schedule]，用于存储编码对应的调度方案;</p>
<p>​                                定义过程涉及函数size，能够返回特点数组变量的行数和列数</p>
<p>​                                Size(数组变量名)：返回两个值，第一个值为数组的行数</p>
<p>​                                                                                        第二个值为数组的列数</p>
<p>​                                Size(数组变量名,1)：返回一个值，是数组第一个维度的大小，即为数组的行数</p>
<p>​                                Size(数组变量名,2)：返回一个值，是数组第二个维度的大小，即为数组的列数</p>
<p>​                step2.2: 根据chrome和data，将schedule数组填充起来</p>
<p>​                                定义长度为jobQty的一维数组，用于存储各个作业当前工序最早可开工时间，或者当前作业前一工序的完工时间，jobCanStartTime；</p>
<p>​                                定义长度为jobQty的一维数组，用于存储各个作业当前拟排产的工序号，jobProcessId;</p>
<p>​                                循环对chrome中每个字段[对应特定作业]，完成工序号、设备号和开工时间、完工时间的生成；</p>
<p>​                                以FT06算例数据为例，假设当前的chrome内容如下：                            </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
</tr>
</thead>
<tbody><tr>
<td><strong>jobId</strong></td>
<td>6</td>
<td>2</td>
<td>4</td>
<td>6</td>
<td>6</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>6</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td><strong>序号</strong></td>
<td><strong>19</strong></td>
<td><strong>20</strong></td>
<td><strong>21</strong></td>
<td><strong>22</strong></td>
<td><strong>23</strong></td>
<td><strong>24</strong></td>
<td><strong>25</strong></td>
<td><strong>26</strong></td>
<td><strong>27</strong></td>
<td><strong>28</strong></td>
<td><strong>29</strong></td>
<td><strong>30</strong></td>
<td><strong>31</strong></td>
<td><strong>32</strong></td>
<td><strong>33</strong></td>
<td><strong>34</strong></td>
<td><strong>35</strong></td>
<td><strong>36</strong></td>
</tr>
<tr>
<td><strong>jobId</strong></td>
<td>5</td>
<td>3</td>
<td>3</td>
<td>6</td>
<td>6</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>1</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>4</td>
</tr>
</tbody></table>
<p>​            设备列=2*工序值-1</p>
<p>​            step2.3：向schedule安排chrome对应的具体的开工和完工时间</p>
<p>​                            当获得了当前jobId、machId、procId,从schedule中提取第二列数值为machId值的全部行，</p>
<p>​                                [1]如果没找到对应的行，表示这个machId值的设备还没有工作；</p>
<p>​                                    直接向schedule中添加一条数据，第四列startTime就是jobId的可开工时间，第五列endTime为第四列数据+data                                    中的工时数据；</p>
<p>​                                [2]如果找到了至少一行数据，则表示这个machId值对应设备已经安排了作业；</p>
<p>​                                    就需要判断具体将开工时间和完工时间安排在什么时段，首先将新的数组按照开工时间升序排序；然后考虑三种情                                    况，进行作业安排:</p>
<p>​                                    （1）是否能排到该机器的第一个作业之前；</p>
<p>​                                    （2）是否能排到其他作业之前；</p>
<p>​                                    （3）是否需要排到最后一个作业之后；</p>
<h2 id="根据调度方案绘制Gant图"><a href="#根据调度方案绘制Gant图" class="headerlink" title="根据调度方案绘制Gant图"></a>根据调度方案绘制Gant图</h2><p>step1：熟悉绘图命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;line([1 2],[4 4],&#x27;lineWidth&#x27;,4)</span><br><span class="line">&gt;&gt;line([4 6],[5 5],&#x27;lineWidth&#x27;,4)</span><br><span class="line">&gt;&gt;line([3 4],[4.5 4.5],&#x27;lineWidth&#x27;,6,&#x27;color&#x27;,&#x27;red&#x27;)</span><br><span class="line">&gt;&gt;ylim([3 6])</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311545034.png" alt="image-20210805112452077" style="zoom:50%;">

<p>step2: 编写根据调度方案数据来进行gant图绘制程序</p>
<p>step3：对gant图进行美化设计：</p>
<p>​             轴坐标范围设置，ylim</p>
<p>​            线条的宽度，属性：lineWidth</p>
<p>​            线条对应的作业编号、工序编号，text()</p>
<p>​            线条颜色设定不同色，属性:color, [1]使用标准颜色实现，r，g，b</p>
<p>​                                                                      [2]使用三元组数据来实现相同作业的甘特图形状为同一种颜色</p>
<h2 id="根据调度方案的适应度-目标函数的值"><a href="#根据调度方案的适应度-目标函数的值" class="headerlink" title="根据调度方案的适应度-目标函数的值"></a>根据调度方案的适应度-目标函数的值</h2><p>目标函数：最大完工时间</p>
<p>目标：最小化最大完工时间</p>
<h2 id="轮盘赌复制的实现"><a href="#轮盘赌复制的实现" class="headerlink" title="轮盘赌复制的实现"></a>轮盘赌复制的实现</h2><p><strong>原理说明：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311545370.png" alt="image-20210810105919625"></p>
<p>复制程序是遗传算法主程序的一步</p>
<p>step1：将遗传算法主程序的循环结构写出来</p>
<p>step2：复制程序设计</p>
<p>​    step2.1：计算种群每条染色体的适应度函数值-数组，fitness</p>
<p>​    step2.2：将适应度数组升序排序，同时保留对应适应度值的编码序号,利用sortrows函数；</p>
<p>​    step2.3：获获得每个染色体的遗传参考值、归一化值、累计概率值</p>
<p>​    step2.4：从现有的pop个染色体中根据轮盘赌选择pop个染色体，形成新的种群</p>
<p>​    </p>
<h2 id="交叉操作的实现"><a href="#交叉操作的实现" class="headerlink" title="交叉操作的实现"></a>交叉操作的实现</h2><p>编程实现部分映射交叉规则的交叉操作，<strong>两点交叉</strong></p>
<p>step1：对染色体群体中前后相邻的两条染色体，根据交叉概率决定这两个染色体是否进行交叉操作；如果进行交叉操作，则执行step2，否则继续查找后面两条相邻染色体进行判断，直至所有染色体判断完毕；</p>
<p>step2： 随机生成[1：n*m]之间的两个点p1和p2，n * m是编码长度</p>
<p>step3：将父代染色体C1和C2在p1和p2两点间的基因片段交换，形成新的子代D1和D2</p>
<p>step4：为子代D1和D2进行有效性处理，编码不能有缺或者重复</p>
<p>​    step4.1:将两个交换片段对比，将不能抵消的代码保留下来；</p>
<p>​    step4.2：将不能抵消的代码逐次对子串进行替换；</p>
<h2 id="变异操作的matlab实现"><a href="#变异操作的matlab实现" class="headerlink" title="变异操作的matlab实现"></a>变异操作的matlab实现</h2><p>三种变异操作方式：</p>
<p>​                            互换</p>
<p>​                            逆序</p>
<p>​                            插入</p>
<p>涉及函数：circleshift</p>
<h2 id="JSP遗传算法集成"><a href="#JSP遗传算法集成" class="headerlink" title="JSP遗传算法集成"></a>JSP遗传算法集成</h2><p>step1：将算法迭代过程中的最优解保留</p>
<h1 id="Flow-Shop调度及其遗传算法"><a href="#Flow-Shop调度及其遗传算法" class="headerlink" title="Flow Shop调度及其遗传算法"></a>Flow Shop调度及其遗传算法</h1><h2 id="流水车间调度问题Flow-Shop-Scheduling-Problem概述"><a href="#流水车间调度问题Flow-Shop-Scheduling-Problem概述" class="headerlink" title="流水车间调度问题Flow Shop Scheduling Problem概述"></a>流水车间调度问题Flow Shop Scheduling Problem概述</h2><h3 id="FSP的基本特点"><a href="#FSP的基本特点" class="headerlink" title="FSP的基本特点"></a>FSP的基本特点</h3><p>​        车间要进行多个批次（多个种类）产品的生产</p>
<p>​        这些批次或种类的产品的工艺路线都是相同的，不同的是在每台机器上的加工时间</p>
<p>不同：</p>
<p>​        每个工序中的机器数量为1台</p>
<p>特别：</p>
<p>​        置换流水车间调度问题（PFSP）中，作业在每台设备上的加工顺序都相同</p>
<h2 id="FSP典型问题-算例"><a href="#FSP典型问题-算例" class="headerlink" title="FSP典型问题-算例"></a>FSP典型问题-算例</h2><p>参考算例：<a target="_blank" rel="noopener" href="http://people.brunel.ac.uk/~mastjjb/jeb/info.html">http://people.brunel.ac.uk/~mastjjb/jeb/info.html</a></p>
<h2 id="遗传算法求解PFSP"><a href="#遗传算法求解PFSP" class="headerlink" title="遗传算法求解PFSP"></a>遗传算法求解PFSP</h2><p>[1]运算流程</p>
<p>step1:初始化-算法控制参数，初始化种群 - [决策变量的编码]</p>
<p>​            N个作业，1、2 、3、…、 n</p>
<p>​            根据编码形成具体的调度方案；</p>
<p>​            将调度方案的适应度值计算出来，最大完工时间；</p>
<p>step2：对种群进行遗传操作</p>
<p>​    step2.1：复制</p>
<p>​    step2.2：交叉</p>
<p>​    step2.3：变异</p>
<p>step3:判断是否终止-算法终止条件是否满足，若是：则执行step4；否则：则执行step2</p>
<p>step4：将算法获得的最优解[满意解]输出</p>
<h2 id="遗传算法求解一般FSP运算流程"><a href="#遗传算法求解一般FSP运算流程" class="headerlink" title="遗传算法求解一般FSP运算流程"></a>遗传算法求解一般FSP运算流程</h2><p>直接使用求解JSP的GA程序</p>
<p>从实验结果可以看出，直接使用随机生成初始染色体种群的话，遗传算法获得的最后的解质量不高，如何改善这种情况？</p>
<p>通过求解PFSP的方式获取一部分初始解，作为染色体种群的子集；</p>
<h1 id="混合流水车间调度优化算法"><a href="#混合流水车间调度优化算法" class="headerlink" title="混合流水车间调度优化算法"></a>混合流水车间调度优化算法</h1><h2 id="混合流水车间调度问题描述"><a href="#混合流水车间调度问题描述" class="headerlink" title="混合流水车间调度问题描述"></a>混合流水车间调度问题描述</h2><p>混合流水车间调度问题(Hybrid Flow Shop Scheduling Problem，HFSP)也称为柔性流水车间调度问题( Flexible-Flow-Shop- Scheduling-Problem，FFSP),因为该问题是在FSP基础上增加了柔性，即在m道工序中至少有一道工序的机器数量为两台或者多台。HFSP的其他特征如下：</p>
<p>（1）车间要进行n个批次或n个种类产品的生产</p>
<p>（2）这些批次或种类的产品的工艺路径都是相同的，都需要经过m道工序，不同的是不同产品在同一道工序上的加工时间可能不同</p>
<p>（3）在m道工序中至少存在一道工序的机器数量为两台或者多台，且这些机器性能相同。</p>
<p>优化目标设定为：最大完工时间最小</p>
<p>按照车间调度问题的三元组表示法，HFSP规范标识为：<img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311546702.png" alt="image-20210817105948222">，</p>
<h2 id="HFSP问题数学模型"><a href="#HFSP问题数学模型" class="headerlink" title="HFSP问题数学模型"></a>HFSP问题数学模型</h2><p>令</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311546656.png" alt="image-20210817151204383"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311546971.png" alt="image-20210817151319051"></p>
<p>HFSP比较经典的混合整数规划模型(Mixed Integer Programming，MIP）如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311546182.png" alt="image-20210817153718402"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311546303.png" alt="image-20210817154051365"></p>
<p>式（2）为任何作业在同一道工序中的所有机器上只能有一个紧前作业的约束；</p>
<p>式（3）为任何作业在同一道工序的所有机器上只能作为一个作业的紧前作业的约束；</p>
<p>式（4）为任何作业的加工不论是否出现在某台机器上，其紧前作业或紧后作业变量必然相等；</p>
<p>式（5）同一个机器上同一个位置的作业之间不存在紧前紧后关系；</p>
<p>式（6）当前机器各个顺序作业完工时间之间的约束；</p>
<p>式（7）特定作业前后道工序之间完工时间的约束；</p>
<p>式（8）为各项作业准备时间为0的约束；</p>
<p>式（9）为各项作业在各道序上的完工时间不小于0约束；</p>
<p>式（10）目标函数与各作业在最后一道序完工时间之间的约束；</p>
<p>式（11）决策变量0-1约束。</p>
<h2 id="HFSP求解GA算法Matlab实现"><a href="#HFSP求解GA算法Matlab实现" class="headerlink" title="HFSP求解GA算法Matlab实现"></a>HFSP求解GA算法Matlab实现</h2><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>step1：问题参数初始化，作业数量n、工序数量m、每个工序机器数量km，每个作业工序工时ptimes[n] [m]</p>
<p>step2：算法参数初始化，种群数量、变异概率、交叉概率、终止条件</p>
<p>step3：种群初始化，如何设计编码规则和解码规则</p>
<p>step4：进行选择、交叉、变异操作</p>
<p>step5：输出最终解</p>
<h3 id="编码和解码规则"><a href="#编码和解码规则" class="headerlink" title="编码和解码规则"></a>编码和解码规则</h3><p><strong>求解的基本思路：</strong></p>
<p>对每个工序的n个作业进行排序，利用优先规则选择最早可用的机器将作业排到对应的机器上</p>
<p><strong>编码规则：</strong></p>
<p>采用基于操作的整数编码方式，具体规则为编码长度只同作业数量n和工序数量m相关，编码长度就是 n * m，编码内容是:1,2,..，n*m之间的整数值。</p>
<p>以n=4，m=3为例进行编码和操作O<del>ji</del>之间的对应关系说明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311545953.png" alt="image-20210817211231782"></p>
<p><strong>解码规则：</strong></p>
<p>解码规则必然同编码规则要相对应，同样以上述示例进行说明。某个染色体为:﹒8 、3、11、2、6、12、5、1、10、 9、4、7</p>
<p>解码步骤：</p>
<p>step1: 当前染色体nowChrome，长度为n*m=L；</p>
<p>step2: 定义详细调度方案数组schedule[L] [5]</p>
<p>Step3：令当前工序i=1</p>
<p>step4：从nowChrome中根据“基础对应表”找出工序i的全部作业的编码，保留其在nowChrome中顺序，假设为procSeq，找出对应的作业编码jobSeq</p>
<p>​        若i=1，则procSeq=[3 2 1 4]，jobSeq=[3 2 1 4]</p>
<p>​        若i=2，则procSeq=[8 6 5 7]，jobSeq=[4 2 1 3]</p>
<p>​        …</p>
<p>step5：根据当前工序i的作业编码排序jobSeq，将作业安排到机器上</p>
<p>​            以i=1的jobSeq=[3 2 1 4]为例说明如何获得具体调度方案表</p>
<p>​        step5.1：令j=1</p>
<p>​        step5.2：获得jobSeq[j]的作业编号nowJ，从而获得ptimes[nowJ] [i]这个作业工时</p>
<p>​        step5.3：将作业nowJ根据优先规则安排到最早可用机器，并完成schedule一行数据的设定</p>
<p>​                        方法1：由工序i可以获得当前可以机器的编号nowMachIds，利用类似于下表的数组machProcArray：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311547743.png" alt="image-20210818182417143"></p>
<p>​                        方法2：较好的一种方式：</p>
<p>​                        （1）从schedule中查看可用机器id的全部排产数据，存入nowSchedule；</p>
<p>​                        （2）根据nowSchedule中每台机器的排产数据，生成emptySlot数据</p>
<p>​                                case1：某个机器id在nowSchedule中有数据，则将其按照startTime升序排序，然后逐条生成emptySlot</p>
<p>​                                例如现有排序如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311547569.png" alt="image-20210818201327265"></p>
<p>​                                生成的emptySlot如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuluotianhan/picgo/img/202201311547052.png" alt="image-20210818201424084"></p>
<p>​                        （3）对emptySlot利用startTime进行升序排序，逐条判断该slot是否能够安排拟排产的操作</p>
<p>​                            【<strong>操作所需的时间是否&lt;=slot的间距</strong>】</p>
<p>​        step5.4：j=j+1，如果j&lt;=n,执行step5.2；否则执行step6；</p>
<p>step6：令i=i+1，如果i&lt;=m,则执行step3；否则解码结束。</p>
<h3 id="遗传操作选择"><a href="#遗传操作选择" class="headerlink" title="遗传操作选择"></a>遗传操作选择</h3><p>（1）选择操作Selection，采用精英保留策略，保留精英数量为5；</p>
<p>（2）交叉操作Crossover</p>
<p>（3）变异操作mute</p>
<h3 id="Matlab编写GA算法"><a href="#Matlab编写GA算法" class="headerlink" title="Matlab编写GA算法"></a>Matlab编写GA算法</h3><p>step1：问题参数初始化，作业数量n、工序数量m、每个工序机器数量km，每个作业工序工时ptimes[n] [m]</p>
<p>step2：算法参数初始化，种群数量、变异概率、交叉概率、终止条件</p>
<p>step3：种群初始化，如何设计编码规则和解码规则：</p>
<p>​            确定编码规则以进行种群初始化；</p>
<p>​            确定解码规则获取详细的调度方案；</p>
<p>​            有具体的调度方案，既可以计算所考虑的适应度函数、目标函数；</p>
<p>​            最大完工时间：schedule(:,)当中的最大值；</p>
<p>​            每台机器的利用率：schedule可知各机器工作时间。利用率=工作时间/总时间；</p>
<p>​            作业的通过时间：最终完工时间—第一道序的开工时间；</p>
<p>​            适应度函数计算            </p>
<p>step4：进行选择、交叉、变异操作</p>
<p>​        </p>
<p>step5：输出最终解</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">木子士心豪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yuluotianhan.github.io/2022/01/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">https://yuluotianhan.github.io/2022/01/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yuluotianhan.github.io" target="_blank">木子士心豪の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">进化算法笔记</a></div><div class="post_share"><div class="social-share" data-image="https://i.picsum.photos/id/641/2509/1673.jpg?hmac=ECuwhiaywfcq8Uz33JwR66SNqYHg5gs-XEh4NzV7uq8" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/01/25/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用hexo搭建个人博客</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/tailuo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木子士心豪</div><div class="author-info__description">幸吾所爱，无谓山海</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuluotianhan"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuluotianhan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1206295906@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">算法笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">遗传算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">编码规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">二进制编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E9%9B%B7%E7%A0%81%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">格雷码编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">浮点数编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%90%88%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">符合编码方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%82%E6%95%B0%E7%BA%A7%E8%81%94%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">多参数级联编码方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%82%E6%95%B0%E4%BA%A4%E5%8F%89%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">多参数交叉编码方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">适应度函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E7%9A%84%E5%B0%BA%E5%BA%A6%E5%8F%98%E6%8D%A2"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">适应的尺度变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">选择算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E4%BE%8B%E9%80%89%E6%8B%A9%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">比例选择算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E4%BF%9D%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">最优保存策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%BC%8F%E9%87%87%E6%A0%B7%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">确定式采样选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%9B%9E%E6%94%BE%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">无回放随机选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%9B%9E%E6%94%BE%E4%BD%99%E6%95%B0%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">无回放余数随机选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">排序选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%81%94%E8%B5%9B%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">随机联赛选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.4.</span> <span class="toc-text">交叉算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E4%BA%A4%E5%8F%89"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">单点交叉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%82%B9%E4%BA%A4%E5%8F%89%E4%B8%8E%E5%A4%9A%E7%82%B9%E4%BA%A4%E5%8F%89"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">双点交叉与多点交叉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%87%E5%8C%80%E4%BA%A4%E5%8F%89"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">均匀交叉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E4%BA%A4%E5%8F%89"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">算术交叉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POX%E4%BA%A4%E5%8F%89%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">POX交叉算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPX-%E4%BA%A4%E5%8F%89%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">RPX 交叉算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FRG-Fragment-reordering-crossover-%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">FRG (Fragment reordering crossover) 算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WMX-weight-mapping-crossover-%EF%BC%8C%E5%9F%BA%E4%BA%8E%E4%B8%A4%E7%82%B9%E7%9A%84%E6%9D%83%E9%87%8D%E6%98%A0%E5%B0%84%E4%BA%A4%E5%8F%89-%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">WMX(weight mapping crossover ，基于两点的权重映射交叉)算子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%BC%82%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.5.</span> <span class="toc-text">变异算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%8D%E5%8F%98%E5%BC%82"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">基本位变异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%87%E5%8C%80%E5%8F%98%E5%BC%82"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">均匀变异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%8F%98%E5%BC%82"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">边界变异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%9D%87%E5%8C%80%E5%8F%98%E5%BC%82"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">非均匀变异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%8F%98%E5%BC%82"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">高斯变异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E5%8F%98%E5%BC%82%E7%AE%97%E5%AD%90"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">实际问题变异算子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">遗传算法的运行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.7.</span> <span class="toc-text">约束条件的处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%A9%BA%E9%97%B4%E9%99%90%E5%AE%9A%E6%B3%95"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">搜索空间限定法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E8%A7%A3%E5%8F%98%E6%8D%A2%E6%B3%95"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">可行解变换法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%9A%E5%87%BD%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">罚函数法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E7%BA%A7%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.</span> <span class="toc-text">遗传算法的高级实现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E4%BD%8D%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">倒位算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B0%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">到位操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E4%BD%8D%E7%AE%97%E5%AD%90%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">倒位算子的应用实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%80%8D%E4%BD%93%E4%B8%8E%E6%98%BE%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">二倍体与显性操作算子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Harmony-Search-HS-%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">Harmony Search(HS)算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%A3%B0%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">和声搜索算法的原理及结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%A3%B0%E8%AE%B0%E5%BF%86%E5%BA%93%E4%BF%9D%E7%95%99%E6%A6%82%E7%8E%87%EF%BC%88HMCR%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">和声记忆库保留概率（HMCR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E8%B0%83%E8%B0%83%E8%8A%82%E7%8E%87%EF%BC%88PAR%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">音调调节率（PAR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%A3%B0%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4%E4%B8%8E%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">和声搜索算法的主要步骤与流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0JSP%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">遗传算法实现JSP优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Matlab%E7%94%9F%E6%88%90JSP%E7%9A%84GA%E7%BC%96%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">Matlab生成JSP的GA编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%BC%96%E7%A0%81%E7%94%9F%E6%88%90%E5%85%B7%E4%BD%93%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.</span> <span class="toc-text">根据编码生成具体调度方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E7%BB%98%E5%88%B6Gant%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">根据调度方案绘制Gant图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E7%9A%84%E9%80%82%E5%BA%94%E5%BA%A6-%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-number">2.4.</span> <span class="toc-text">根据调度方案的适应度-目标函数的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E7%9B%98%E8%B5%8C%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.</span> <span class="toc-text">轮盘赌复制的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">交叉操作的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E5%BC%82%E6%93%8D%E4%BD%9C%E7%9A%84matlab%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.</span> <span class="toc-text">变异操作的matlab实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSP%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E9%9B%86%E6%88%90"><span class="toc-number">2.8.</span> <span class="toc-text">JSP遗传算法集成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flow-Shop%E8%B0%83%E5%BA%A6%E5%8F%8A%E5%85%B6%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">Flow Shop调度及其遗传算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98Flow-Shop-Scheduling-Problem%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">流水车间调度问题Flow Shop Scheduling Problem概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FSP%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">FSP的基本特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FSP%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98-%E7%AE%97%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">FSP典型问题-算例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3PFSP"><span class="toc-number">3.3.</span> <span class="toc-text">遗传算法求解PFSP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E4%B8%80%E8%88%ACFSP%E8%BF%90%E7%AE%97%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">遗传算法求解一般FSP运算流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%B5%81%E6%B0%B4%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">混合流水车间调度优化算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%B5%81%E6%B0%B4%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">混合流水车间调度问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HFSP%E9%97%AE%E9%A2%98%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">HFSP问题数学模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HFSP%E6%B1%82%E8%A7%A3GA%E7%AE%97%E6%B3%95Matlab%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">HFSP求解GA算法Matlab实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="toc-number">4.3.1.</span> <span class="toc-text">算法框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%A7%84%E5%88%99"><span class="toc-number">4.3.2.</span> <span class="toc-text">编码和解码规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.3.</span> <span class="toc-text">遗传操作选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matlab%E7%BC%96%E5%86%99GA%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">Matlab编写GA算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="智能进化算法"><img src="https://i.picsum.photos/id/641/2509/1673.jpg?hmac=ECuwhiaywfcq8Uz33JwR66SNqYHg5gs-XEh4NzV7uq8" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能进化算法"/></a><div class="content"><a class="title" href="/2022/01/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="智能进化算法">智能进化算法</a><time datetime="2022-01-30T13:30:00.000Z" title="发表于 2022-01-30 21:30:00">2022-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/25/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="使用hexo搭建个人博客"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用hexo搭建个人博客"/></a><div class="content"><a class="title" href="/2022/01/25/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="使用hexo搭建个人博客">使用hexo搭建个人博客</a><time datetime="2022-01-25T07:10:42.000Z" title="发表于 2022-01-25 15:10:42">2022-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 木子士心豪</div><div class="footer_custom_text">山水一程，相遇已是三生有幸(^_-)</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>